"use strict";
var src_1 = require("../src");
var formatting_1 = require("../src/formatting");
var isTypeArraySupported = typeof Float32Array === 'undefined';
;
/**
 * Map of Color converters.  By subtracting the from-format from the to-format, we can
 * quickly map to the right converter. 1-2 and 2-1 yield different results, so this
 * allows us to choose the right converter observing the direction correcly
 */
var converters = (_a = {},
    _a[1 /* RGB */ - 2 /* HSL */] = RGBtoHSL,
    _a[2 /* HSL */ - 1 /* RGB */] = HSLtoRGB,
    _a);
/**
 * Named colors in the CSS spec.
 * transparent is not technically a named color, but it fits into this pattern
 */
var namedColors = {
    transparent: [0, 0, 0, 0],
    black: [0, 0, 0, 1],
    silver: [192, 192, 192, 1],
    gray: [128, 128, 128, 1],
    white: [255, 255, 255, 1],
    maroon: [128, 0, 0, 1],
    red: [255, 0, 0, 1],
    purple: [128, 0, 128, 1],
    fuchsia: [255, 0, 255, 1],
    green: [0, 128, 0, 1],
    lime: [0, 255, 0, 1],
    olive: [128, 128, 0, 1],
    yellow: [255, 255, 0, 1],
    navy: [0, 0, 128, 1],
    blue: [0, 0, 255, 1],
    teal: [0, 128, 128, 1],
    aqua: [0, 255, 255, 1]
};
/**
 * Converts from one format to another format
 */
function convert(fromFormat, toFormat, c0, c1, c2, c3, hasAlpha) {
    return fromFormat === toFormat
        ? new ColorHelper(fromFormat, c0, c1, c2, c3, hasAlpha)
        : converters[fromFormat - toFormat](c0, c1, c2, c3, hasAlpha);
}
function colorArray(c0, c1, c2, c3) {
    if (!isTypeArraySupported) {
        return [c0 || 0, c1 || 0, c2 || 0, c3 || 0];
    }
    var a = new Float32Array(4);
    a[0] = c0 || 0;
    a[1] = c1 || 0;
    a[2] = c2 || 0;
    a[3] = c3 || 0;
    return a;
}
/**
 * Creates a color from a hex color code or named color.
 * e.g. color('red') or color('#FF0000') or color('#F00'))
 */
function color(value) {
    return parseNamedColor(value) || parseHexCode(value) || parseNamedColor('red');
}
exports.color = color;
/**
 * Creates a color from hue, saturation, and lightness.  Alpha is automatically set to 100%
 */
function hsl(hue, saturation, lightness) {
    return new ColorHelper(2 /* HSL */, hue, formatting_1.ensurePercent(saturation), formatting_1.ensurePercent(lightness), 1, false);
}
exports.hsl = hsl;
/**
 * Creates a color from hue, saturation, lightness, and alpha
 */
function hsla(hue, saturation, lightness, opacity) {
    return new ColorHelper(2 /* HSL */, hue, formatting_1.ensurePercent(saturation), formatting_1.ensurePercent(lightness), formatting_1.ensurePercent(opacity), true);
}
exports.hsla = hsla;
/**
 * Creates a color form the red, blue, and green color space.  Alpha is automatically set to 100%
 */
function rgb(red, blue, green) {
    return new ColorHelper(1 /* RGB */, red, blue, green, 1, false);
}
exports.rgb = rgb;
/**
 * Creates a color form the red, blue, green, and alpha in the color space
 */
function rgba(red, blue, green, alpha) {
    return new ColorHelper(1 /* RGB */, red, blue, green, formatting_1.ensurePercent(alpha), true);
}
exports.rgba = rgba;
/**
 * A CSS Color.  Includes utilities for converting between color types
 */
var ColorHelper = (function () {
    function ColorHelper(colorFormat, c0, c1, c2, c3, hasAlpha) {
        this.type = 'color';
        this._format = colorFormat;
        this._values = colorArray(c0, c1, c2, c3);
        this._hasAlpha = hasAlpha;
    }
    /**
     * Converts to the Hue, Saturation, Lightness color space
     */
    ColorHelper.prototype.toHSL = function () {
        var v = this._values;
        return convert(this._format, 2 /* HSL */, v[0], v[1], v[2], v[3], false);
    };
    /**
     * Converts to the Hue, Saturation, Lightness color space and adds an alpha channel
     */
    ColorHelper.prototype.toHSLA = function () {
        var v = this._values;
        return convert(this._format, 2 /* HSL */, v[0], v[1], v[2], v[3], true);
    };
    /**
     * Converts to the Red, Green, Blue color space
     */
    ColorHelper.prototype.toRGB = function () {
        var v = this._values;
        return convert(this._format, 1 /* RGB */, v[0], v[1], v[2], v[3], false);
    };
    /**
     * Converts to the Red, Green, Blue color space and adds an alpha channel
     */
    ColorHelper.prototype.toRGBA = function () {
        var v = this._values;
        return convert(this._format, 1 /* RGB */, v[0], v[1], v[2], v[3], true);
    };
    /**
     * Converts the stored color into string form (which is used by Free Style)
     */
    ColorHelper.prototype.toString = function () {
        var _a = this._values, c1 = _a[0], c2 = _a[1], c3 = _a[2], c4 = _a[3];
        var format = this._format;
        var hasAlpha = this._hasAlpha;
        switch (format) {
            case 2 /* HSL */:
                return hasAlpha
                    ? src_1.cssFunction('hsla', c1, formatting_1.formatPercent(c2), formatting_1.formatPercent(c3), c4)
                    : src_1.cssFunction('hsl', c1, formatting_1.formatPercent(c2), formatting_1.formatPercent(c3));
            case 1 /* RGB */:
                return hasAlpha
                    ? src_1.cssFunction('rgba', c1, c2, c3, c4)
                    : src_1.cssFunction('rgb', c1, c2, c3);
        }
        // throw an error?
        throw new Error('Invalid color format');
    };
    return ColorHelper;
}());
exports.ColorHelper = ColorHelper;
function RGBtoHSL(c0, c1, c2, c3, hasAlpha) {
    var r = c0 / 255;
    var g = c1 / 255;
    var b = c2 / 255;
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h;
    if (max === min) {
        h = 0;
    }
    else if (r === max) {
        h = (g - b) / delta;
    }
    else if (g === max) {
        h = 2 + (b - r) / delta;
    }
    else if (b === max) {
        h = 4 + (r - g) / delta;
    }
    else {
        h = 0;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
        h += 360;
    }
    var l = (min + max) / 2;
    var s;
    if (max === min) {
        s = 0;
    }
    else if (l <= 0.5) {
        s = delta / (max + min);
    }
    else {
        s = delta / (2 - max - min);
    }
    return new ColorHelper(2 /* HSL */, h, s, l, c3, hasAlpha);
}
;
function HSLtoRGB(c0, c1, c2, c3, hasAlpha) {
    var h = c0 / 360;
    var s = c1;
    var l = c2;
    if (s === 0) {
        var val = l * 255;
        return new ColorHelper(1 /* RGB */, val, val, val, c3, hasAlpha);
    }
    var t2 = l < .5 ? l * (1 + s) : l + s - l * s;
    var t1 = 2 * l - t2;
    var r = 0, g = 0, b = 0;
    for (var i = 0; i < 3; i++) {
        var t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
            t3++;
        }
        if (t3 > 1) {
            t3--;
        }
        var val = void 0;
        if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
        }
        else if (2 * t3 < 1) {
            val = t2;
        }
        else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        }
        else {
            val = t1;
        }
        val *= 255;
        // manually set variables instead of using an array
        if (i === 0) {
            r = val;
        }
        else if (i === 1) {
            g = val;
        }
        else {
            b = val;
        }
    }
    return new ColorHelper(1 /* RGB */, r, g, b, c3, hasAlpha);
}
;
function parseNamedColor(stringValue) {
    var v = namedColors[stringValue];
    if (!v) {
        return undefined;
    }
    return new ColorHelper(1 /* RGB */, v[0], v[1], v[2], v[3], v[3] < 1);
}
function parseHexCode(stringValue) {
    var match = stringValue.match(/#(([a-f0-9]{6})|([a-f0-9]{3}))$/i);
    if (!match) {
        return undefined;
    }
    var hex = match[1];
    var hexColor = parseInt(hex.length === 3
        ? hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2]
        : hex, 16);
    return new ColorHelper(1 /* RGB */, (hexColor >> 16) & 0xFF, (hexColor >> 8) & 0xFF, hexColor & 0xFF, 1, false);
}
;
var _a;
